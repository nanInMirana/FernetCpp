#ifndef BASE64_H
#define BASE64_H

#include <vector>
#include <string>

namespace fernet
{
#define ENCODE_URL

    typedef unsigned char BYTE;

#ifndef ENCODE_URL
    constexpr char base64_chars[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";

    constexpr BYTE base64_T[] = {
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 62, 255, 255, 255, 63,
        52, 53, 54, 55, 56, 57, 58, 59,
        60, 61, 255, 255, 255, 255, 255, 255,
        255, 0, 1, 2, 3, 4, 5, 6,
        7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22,
        23, 24, 25, 255, 255, 255, 255, 255,
        255, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48,
        49, 50, 51, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255};

#else
    constexpr char base64_chars[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789-_";

    constexpr BYTE base64_T[] = {
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 62, 255, 255,
        52, 53, 54, 55, 56, 57, 58, 59,
        60, 61, 255, 255, 255, 255, 255, 255,
        255, 0, 1, 2, 3, 4, 5, 6,
        7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22,
        23, 24, 25, 255, 255, 255, 255, 63,
        255, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48,
        49, 50, 51, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255};

#endif

    static void base64_encode(
        BYTE *b_in, size_t b_in_len,
        BYTE **b_out, size_t *b_out_len)
    {

        size_t stp = b_in_len / 3;
        size_t pad = b_in_len % 3;
        *b_out_len = (stp + (pad > 0)) * 4;
        *b_out = (BYTE *)malloc(*b_out_len);

        size_t a = 0, b = 0;
        for (size_t i = 0; i < stp; ++i)
        {
            (*b_out)[b++] = base64_chars[(b_in[a] & 0xfc) >> 2];
            (*b_out)[b++] = base64_chars[((b_in[a] & 0x03) << 4) +
                                         ((b_in[a + 1] & 0xf0) >> 4)];
            (*b_out)[b++] = base64_chars[((b_in[a + 1] & 0x0f) << 2) +
                                         ((b_in[a + 2] & 0xc0) >> 6)];
            (*b_out)[b++] = base64_chars[b_in[a + 2] & 0x3f];
            a += 3;
        }
        if (pad)
        {
            if (pad == 1)
            {
                (*b_out)[b++] = base64_chars[(b_in[a] & 0xfc) >> 2];
                (*b_out)[b++] = base64_chars[((b_in[a] & 0x03) << 4)];
            }
            else if (pad == 2)
            {
                (*b_out)[b++] = base64_chars[(b_in[a] & 0xfc) >> 2];
                (*b_out)[b++] = base64_chars[((b_in[a] & 0x03) << 4) +
                                             ((b_in[a + 1] & 0xf0) >> 4)];
                (*b_out)[b++] = base64_chars[((b_in[a + 1] & 0x0f) << 2)];
            }
            while (b < *b_out_len)
            {
                (*b_out)[b++] = '=';
            }
        }
    }

    static void base64_decode(
        BYTE *b_in, size_t b_in_len,
        BYTE **b_out, size_t *b_out_len)
    {

        size_t stp = b_in_len / 4;
        size_t pad = b_in_len % 4;
        *b_out_len = (stp + (pad > 0)) * 3;
        *b_out = (BYTE *)malloc(*b_out_len);

        size_t a = 0, b = 0;
        for (size_t i = 0; i < stp; ++i)
        {
            (*b_out)[b++] = (base64_T[b_in[a]] << 2) + ((base64_T[b_in[a + 1]] & 0x30) >> 4);
            if (base64_T[b_in[a + 2]] == 255)
                break;
            (*b_out)[b++] = ((base64_T[b_in[a + 1]] & 0xf) << 4) + ((base64_T[b_in[a + 2]] & 0x3c) >> 2);
            if (base64_T[b_in[a + 3]] == 255)
                break;
            (*b_out)[b++] = ((base64_T[b_in[a + 2]] & 0x3) << 6) + base64_T[b_in[a + 3]];
            a += 4;
        }
        *b_out_len = b;
    }
}
#endif
